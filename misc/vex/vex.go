package main

import (
	"bytes"
	"context"
	"crypto/sha256"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path"
	"sort"
	"strings"
	"time"

	"github.com/openvex/go-vex/pkg/vex"
	"github.com/package-url/packageurl-go"
	"github.com/samber/lo"
	"golang.org/x/vuln/scan"

	"github.com/aquasecurity/go-version/pkg/version"
	"github.com/aquasecurity/trivy/pkg/log"
)

const (
	repoURL = "https://github.com/aquasecurity/trivy"
	maxTags = 2
)

var (
	productID = &packageurl.PackageURL{
		Type:      packageurl.TypeGolang,
		Namespace: "github.com/aquasecurity",
		Name:      "trivy",
	}
)

type VulnerabilityFinding struct {
	Finding Finding `json:"finding"`
}

type Finding struct {
	OSV          string  `json:"osv"`
	FixedVersion string  `json:"fixed_version"`
	Trace        []Trace `json:"trace"`
}

type Trace struct {
	Module  string `json:"module"`
	Version string `json:"version"`
	Package string `json:"package"`
}

func main() {
	if err := run(); err != nil {
		log.Fatal("Fatal error", log.Err(err))
	}
}

func run() error {
	log.InitLogger(false, false)

	cloneDir := flag.String("dir", "trivy", "Directory to clone the repository")
	output := flag.String("output", ".vex/trivy.openvex.json", "Output file")
	flag.Parse()

	ctx := context.Background()
	if _, err := cloneOrPullRepo(ctx, *cloneDir); err != nil {
		return err
	}

	defer func() {
		// Ensure we are on the main branch
		_, _ = checkoutMain(ctx, *cloneDir)
	}()

	// Save the current working directory
	wd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get current working directory: %w", err)
	}

	// Change to the target directory as govulncheck doesn't support Dir
	// cf. https://github.com/golang/go/blob/6d89b38ed86e0bfa0ddaba08dc4071e6bb300eea/src/os/exec/exec.go#L171-L174
	if err = os.Chdir(*cloneDir); err != nil {
		return fmt.Errorf("failed to change to directory %s: %w", *cloneDir, err)
	}

	tags, err := getLatestTags(ctx, *cloneDir)
	if err != nil {
		return err
	}

	log.Info("Latest tags", log.Any("tags", tags))
	var docs []*vex.VEX
	for _, tag := range tags {
		doc, err := processTag(ctx, *cloneDir, tag)
		if err != nil {
			return err
		}
		docs = append(docs, doc)
	}

	// Change back to the original directory when we're done
	if err = os.Chdir(wd); err != nil {
		return fmt.Errorf("failed to change back to original directory: %w", err)
	}

	if err = updateVEX(*output, combineDocs(docs)); err != nil {
		return err
	}

	return nil
}

func cloneOrPullRepo(ctx context.Context, dir string) ([]byte, error) {
	if _, err := os.Stat(dir); os.IsNotExist(err) {
		return runCommandWithTimeout(ctx, 2*time.Minute, "git", "clone", repoURL, dir)
	}

	if _, err := checkoutMain(ctx, dir); err != nil {
		return nil, fmt.Errorf("failed to checkout main: %w", err)
	}
	return runCommandWithTimeout(ctx, 2*time.Minute, "git", "-C", dir, "pull", "--tags")
}

func checkoutMain(ctx context.Context, dir string) ([]byte, error) {
	return runCommandWithTimeout(ctx, 1*time.Minute, "git", "-C", dir, "checkout", "main")
}

func getLatestTags(ctx context.Context, dir string) ([]string, error) {
	output, err := runCommandWithTimeout(ctx, 1*time.Minute, "git", "tag")
	if err != nil {
		return nil, fmt.Errorf("failed to get tags: %w", err)
	}

	tags := strings.Split(strings.TrimSpace(string(output)), "\n")
	versions := make([]version.Version, 0, len(tags))

	for _, tag := range tags {
		v, err := version.Parse(tag)
		if err == nil {
			versions = append(versions, v)
		}
	}

	sort.Slice(versions, func(i, j int) bool {
		return versions[i].GreaterThan(versions[j])
	})

	result := make([]string, 0, maxTags)
	for i := 0; i < len(versions) && i < maxTags; i++ {
		result = append(result, versions[i].Original())
	}

	return result, nil
}

func processTag(ctx context.Context, dir, tag string) (*vex.VEX, error) {
	log.Info("Processing tag", log.String("tag", tag))
	if _, err := runCommandWithTimeout(ctx, 1*time.Minute, "git", "checkout", tag); err != nil {
		return nil, fmt.Errorf("failed to checkout tag %s: %w", tag, err)
	}

	// Run govulncheck and generate VEX document
	vexDoc, err := generateVEX(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to run govulncheck: %w", err)
	}

	// Run govulncheck and generate JSON result
	// Need to generate JSON as well for the following reasons:
	//   - Subcomponent
	//      - OpenVEX from govulncheck doesn't fill in subcomponents.
	//   - Status
	//      - govulncheck uses "not_affected" for all vulnerabilities.
	//        cf. https://github.com/golang/go/issues/68338
	findings, err := generateJSON(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to run govulncheck: %w", err)
	}

	// Update VEX document generated by govulncheck
	product := *productID // Clone PURL
	product.Version = tag
	var statements []vex.Statement
	for _, stmt := range vexDoc.Statements {
		if stmt.Status == vex.StatusAffected {
			continue
		}
		finding, ok := findings[stmt.Vulnerability.Name]
		if !ok {
			// Considered as "fixed" vulnerabilities
			// cf. https://github.com/golang/go/issues/68338
			stmt.Status = vex.StatusFixed
			continue
		}

		namespace, name := path.Split(finding.Finding.Trace[0].Module)
		subcomponent := &packageurl.PackageURL{
			Type:      packageurl.TypeGolang,
			Namespace: namespace,
			Name:      name,
		}

		stmt.Products = []vex.Product{
			{
				Component: vex.Component{
					ID: product.String(),
					Identifiers: map[vex.IdentifierType]string{
						vex.PURL: product.String(),
					},
				},
				Subcomponents: []vex.Subcomponent{
					{
						Component: vex.Component{
							ID: subcomponent.String(),
							Identifiers: map[vex.IdentifierType]string{
								vex.PURL: subcomponent.String(),
							},
						},
					},
				},
			},
		}
		statements = append(statements, stmt)
	}
	vexDoc.Statements = statements

	f, err := os.Create(fmt.Sprintf("vex-%s.json", tag))
	if err != nil {
		return nil, fmt.Errorf("failed to create VEX file: %w", err)
	}
	defer f.Close()

	if err := json.NewEncoder(f).Encode(vexDoc); err != nil {
		return nil, fmt.Errorf("failed to write VEX file: %w", err)
	}

	return vexDoc, nil
}

func generateVEX(ctx context.Context) (*vex.VEX, error) {
	buf, err := runGovulncheck(ctx, "openvex")
	if err != nil {
		return nil, fmt.Errorf("failed to run govulncheck: %w", err)
	}

	vexDoc, err := vex.Parse(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("failed to parse govulncheck output: %w", err)
	}
	return vexDoc, nil
}

func generateJSON(ctx context.Context) (map[vex.VulnerabilityID]VulnerabilityFinding, error) {
	buf, err := runGovulncheck(ctx, "json")
	if err != nil {
		return nil, fmt.Errorf("failed to run govulncheck: %w", err)
	}

	decoder := json.NewDecoder(buf)
	findings := map[vex.VulnerabilityID]VulnerabilityFinding{}
	for {
		var finding VulnerabilityFinding
		if err := decoder.Decode(&finding); err == io.EOF {
			break
		} else if err != nil {
			return nil, fmt.Errorf("failed to decode govulncheck output: %w", err)
		}
		findings[vex.VulnerabilityID(finding.Finding.OSV)] = finding
	}
	return findings, nil
}

func runGovulncheck(ctx context.Context, format string) (*bytes.Buffer, error) {
	var buf bytes.Buffer
	cmd := scan.Command(ctx, "-format", format, "./...")
	cmd.Stdout = &buf

	log.Info("Running govulncheck", log.String("format", format))
	if err := cmd.Start(); err != nil {
		return nil, fmt.Errorf("failed to start govulncheck: %w", err)
	}

	if err := cmd.Wait(); err != nil {
		return nil, fmt.Errorf("failed to run govulncheck: %w", err)
	}
	return &buf, nil
}

func combineDocs(docs []*vex.VEX) []vex.Statement {
	log.Info("Combining VEX documents", log.Int("docs", len(docs)))
	statements := map[vex.VulnerabilityID]vex.Statement{}
	for _, doc := range docs {
		for _, stmt := range doc.Statements {
			if s, ok := statements[stmt.Vulnerability.Name]; ok {
				s.Products = append(s.Products, stmt.Products...)
				statements[stmt.Vulnerability.Name] = s
			} else {
				statements[stmt.Vulnerability.Name] = stmt
			}
		}
	}
	return lo.Values(statements)
}

func runCommandWithTimeout(ctx context.Context, timeout time.Duration, name string, args ...string) ([]byte, error) {
	ctx, cancel := context.WithTimeout(ctx, timeout)
	defer cancel()

	cmd := exec.CommandContext(ctx, name, args...)
	log.Info("Executing command", log.String("cmd", cmd.String()))

	output, err := cmd.CombinedOutput()
	if err != nil {
		return output, fmt.Errorf("%w, output: %s", err, string(output))
	}

	if errors.Is(ctx.Err(), context.DeadlineExceeded) {
		return nil, fmt.Errorf("command timed out after %v", timeout)
	}

	return output, nil
}

func updateVEX(output string, statements []vex.Statement) error {
	doc, err := vex.Load(output)
	if errors.Is(err, os.ErrNotExist) {
		doc = &vex.VEX{}
	} else if err != nil {
		return err
	}

	d := &vex.VEX{
		Metadata: vex.Metadata{
			Context:   "https://openvex.dev/ns/v0.2.0",
			Author:    "Aqua Security",
			Timestamp: lo.ToPtr(time.Now()),
			Version:   doc.Version + 1,
			Tooling:   "https://pkg.go.dev/golang.org/x/vuln/cmd/govulncheck",
		},
		Statements: statements,
	}
	h, err := hashVEX(d)
	if err != nil {
		return err
	}
	d.ID = "aquasecurity/trivy:" + h

	f, err := os.Create(output)
	if err != nil {
		return err
	}
	defer f.Close()

	e := json.NewEncoder(f)
	e.SetIndent("", "  ")
	if err = e.Encode(d); err != nil {
		return err
	}
	return err
}

func hashVEX(d *vex.VEX) (string, error) {
	out, err := json.Marshal(d)
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("%x", sha256.Sum256(out)), nil
}
