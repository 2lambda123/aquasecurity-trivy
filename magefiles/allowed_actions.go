package main

import (
	"bufio"
	"errors"
	"fmt"
	"os"
	"strings"

	"github.com/antchfx/htmlquery"
	"golang.org/x/net/html"
)

const (
	serviceAuthURL             = "https://docs.aws.amazon.com/service-authorization/latest/reference/"
	serviceActionReferencesURL = "https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html"
	targetFile                 = "pkg/iac/providers/aws/iam/actions.go"
	defaultParallel            = 10
)

func parseServiceURLs(doc *html.Node) ([]string, error) {
	nodes, err := htmlquery.QueryAll(doc, `//div[@class="highlights"]/ul/li/a/@href`)
	if err != nil {
		return nil, fmt.Errorf("failed to search nodes: %w\n", err)
	}

	res := make([]string, 0, len(nodes))

	for _, node := range nodes {
		// <a href="./list_awsaccountmanagement.html">AWS Account Management</a>
		if node.FirstChild != nil {
			res = append(res, serviceAuthURL+node.FirstChild.Data[2:])
		}
	}

	return res, nil
}

func parseActions(url string) ([]string, error) {

	doc, err := htmlquery.LoadURL(url)
	if err != nil {
		return nil, err
	}

	servicePrefix, err := parseServicePrefix(doc)
	if err != nil {
		return nil, err
	}

	actions, err := parseServiceActions(doc)
	if err != nil {
		return nil, err
	}

	res := make([]string, 0, len(actions))

	for _, act := range actions {
		res = append(res, servicePrefix+":"+act)
	}

	fmt.Printf("Parsing of %q actions is completed\n", servicePrefix)

	return res, nil
}

func parseServiceActions(doc *html.Node) ([]string, error) {
	table, err := htmlquery.Query(doc, `//div[@class="table-container"]/div/table/tbody`)
	if table == nil {
		return nil, errors.New("actions table not found")
	}
	if err != nil {
		return nil, fmt.Errorf("failed to query tables: %w\n", err)
	}

	var actions []string

	var f func(*html.Node)
	f = func(n *html.Node) {
		for _, tr := range findSubtags(n, "tr") {
			var action string
			for k, td := range findSubtags(tr, "td") {
				// first column - action
				if k == 0 {
					if a := findSubtag(td, "a"); a != nil && a.FirstChild != nil {
						action = a.FirstChild.Data
					}

					// fourth column - resource type
					// If the column is empty, then the action does not support resource-level permissions
					// and you must specify all resources ("*") in your policy
				} else if action != "" && k == 3 && td.FirstChild == nil {
					actions = append(actions, action)
				}
			}
		}
		for c := n.FirstChild; c != nil; c = c.NextSibling {
			f(c)
		}
	}
	f(table)

	return actions, err
}

func findSubtag(n *html.Node, tagName string) *html.Node {
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		if c.Type == html.ElementNode && c.Data == tagName {
			return c
		}
	}

	return nil
}

func findSubtags(n *html.Node, tagName string) []*html.Node {
	var result []*html.Node
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		if c.Type == html.ElementNode && c.Data == tagName {
			result = append(result, c)
		}
	}
	return result
}

func parseServicePrefix(doc *html.Node) (string, error) {
	nodes, err := htmlquery.QueryAll(doc, `//div[@id="main-col-body"]/p/descendant-or-self::*/text()`)
	if err != nil {
		return "", fmt.Errorf("failed to query paragraph: %w\n", err)
	}

	var sb strings.Builder
	for _, node := range nodes {
		sb.WriteString(node.Data)
	}

	p := sb.String()
	sb.Reset()

	idx := strings.Index(p, "service prefix: ")
	if idx == -1 {
		return "", fmt.Errorf("failed extract service prefix from text: %s\n", p)
	}
	idx += len("service prefix: ")

	if len(p)-1 <= idx {
		return "", fmt.Errorf("failed to parse service prefix from text: %s\n", p)
	}

	var parsed bool
	for _, r := range p[idx:] {
		if r == ')' {
			parsed = true
			break
		}
		sb.WriteRune(r)
	}

	if !parsed {
		return "", fmt.Errorf("failed to parse service prefix from text: %s\n", p)
	}

	return sb.String(), nil
}

func generateFile(path string, actions []string) error {

	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("failed to create file: %w\n", err)
	}
	defer f.Close()

	w := bufio.NewWriter(f)
	_, _ = w.WriteString(
		`// Code generated by mage genallowedactions DO NOT EDIT.

package iam

var allowedActionsForResourceWildcardsMap = map[string]struct{}{
`,
	)

	for _, action := range actions {
		_, _ = w.WriteString("\t\"" + action + "\": {},\n")
	}
	_, _ = w.WriteString("}")

	return w.Flush()
}
